插入缓存：
	在InnoDB存储引擎中，主键是唯一标识。插入聚集索引一般是顺序的，不需要随机读磁盘。因此对主键的插入速度是非常快的。
	但是不可能一张表上只有一个聚集索引，更多情况下会有多个非聚集的辅助索引。数据页会按照主键顺序进行存放，但是对于非聚集索引的叶子节点不再是顺序插入，所以，非聚集索引的会由于随机读造成性能下降。

	1.Insert Buffer：
		对于非聚集索引的插入或者更新操作，不是每一次直接插入索引页中，而是先判断非聚集索引页是否在缓冲池中，若在，直接插入；若不在，则先放到一个Insert Buffer
		中，好似欺骗。看似这个非聚集索引已经插入到叶子节点中，实际并没有。然后以一定的频率和情况将Insert Buffer和辅助索引叶子节点merge。这样通常能将多个插入合并到一个操作中（因为同一个索引页中），这样就提高了非聚集索引插入的性能；
		Insert Buffer使用需要同时满足两个条件：索引是辅助索引和非唯一索引；
		在密集写的情况下，Insert Buffer会占用大量缓冲池内存；
		个人理解：写唯一索引要检查记录是不是存在，所以在修改唯一索引之前,必须把修改的记录相关的索引页读出来才知道是不是唯一,这样Insert Buffer就没意义了，反正要读出来(读带来随机IO)，所以只对非唯一索引有效

	2.Change Buffer：
		1.0.x开始引入Change Buffer，可以认为是Insert Buffer 的升级作用对象仍为非唯一的辅助索引；从这个版本开始，InnoDB可以对DML操作---insert、delete、update都进行都进行缓冲，分别对应Insert Buffer、Delete Buffer和Purge buffer。
		对一条记录进行update造作可能氛围两个过程：
		1.将记录标记为已删除，对应的为Delete Buffer；
		2.真正的将记录删除，对应的是Purge Buffer。（个人理解：这里的删除是将指原来的数据和索引结构中不存在这样的数据了，并不是真正的删除数据。关于Mysql的数据删除，我更倾向于对于主键数据的更新，采用的先删除，后插入的方式，对于非主键更新，则采用原地更新方式）；

	3.Merge Insert Buffer：
		一般在三种情况下会发生：
		1.辅助索引页被读取到缓冲池中：这时候需要确认辅助索引页中是否有记录存放在Insert Buffer中；
		2.Insert Buffer Bitmap页追踪到辅助索引页无可用空间，必须要合并才能空出空间；
		3.Master Thread主动刷新；

两次写：
	doublewrite机制保证页的可靠性；
	如果数据库发生宕机，并且正在写入的页发生损毁，那么单独通过读取redo日志，再恢复到数据库，是无法可靠恢复数据的。
	在重做日志之前，用户先需要一个该页的副本，如果写失效（写完一半宕机），那么写用副本还原该页，然后进行重做；


自适应哈希索引：
	InnoDB会根据访问频率和模式来自动地为某些热点建立哈希索引；

异步IO（AIO）：
	首先对于用户每次发出一个IO请求，等待其执行完毕再发出下一个IO请求是不必要的；
	其次，AIO可以将多个IO合并为一个，提升IOPS，比如，连续页写入；

刷新临近页：
	在写入之前，InnoDB会检查写入页周边的所有页，如果存在，那么一起刷新。AIO可以将多个IO操作合并为一个IO操作。