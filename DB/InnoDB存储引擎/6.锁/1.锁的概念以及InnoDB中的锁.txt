每种数据库，甚至于MySQL中的每种存储引擎对于锁的实现都是不一样的，需要引起注意；

lock与latch：
	latch一般称为闩锁，量级较轻，目的是保证并发线程操作连接资源的争取性；
	lock对象是事务，用来锁定数据库中的对象；
	两者的比较如下：
	————————————————————————————————————————————————————
				|					lock 						|					latch
	————————————————————————————————————————————————————
	 	对象	|					事务						|					线程
	————————————————————————————————————————————————————
		保护	|				整个数据库						|				内存数据结构
	————————————————————————————————————————————————————
		持续时间|				整个事务过程					|					临界资源
	————————————————————————————————————————————————————
		死锁	|通过waits-for graph、time out等机制进行检索处理|无检测处理机制，通过加载顺序保证无死锁发生
	————————————————————————————————————————————————————
		存在	|			Lock Manager的哈希表中				|				每个数据结构的对象中
	————————————————————————————————————————————————————

InnoDB锁的类型：
	共享锁（S Lock）：允许事务读取一行数据；
	排他锁（X Lock）：允许事务删除或更新一行数据；
	如果事务T1获得了行r的共享锁，那么允许事务T2立即获得行r的共享锁，这种情况称为锁兼容；
	如果事务T1获得了行r的共享锁，那么不允许事务T3获得行r的排他锁，这种情况称为锁不兼容；
	X锁和S锁都是行锁；
	同时，InnoDB支持多粒度的锁定，即允许事务在行级和表级上的锁同时存在。所以，InnoDB支持另外的一种锁方式，称为意向锁；
	如果要对记录r行上进行锁定，那么分别需要对数据、表、页上意向锁，最后对记录r锁定；
	意向共享锁（IS Lock）：允许事务获得一张表中某几行的共享锁；
	意向排他锁（IX Lock）：允许事务获得一张表中某几行的排他锁；
	由于InnoDB支持行锁，索引意向锁不会阻塞除全表扫描之外的任何请求；

一致性非锁定读：
	如果读取行正在执行DELETE或UPDATE操作，这时读操作不会因此去等待行上锁的释放，而是会去读取行的一个快照数据；

一致性锁定读：
	InnoDB存储引擎对于select语句支持两种一致性的锁定读：
	SELECT ... FOR UPDATE:对读取行记录加一个X锁，其他任何事务不能对已锁定的行加上任何锁；
	SELECT ... LOCK IN SHARE MODE:对读取行记录加一个S锁，其他事务可以向被锁定行加S锁，但是如果加X锁，则会被阻塞；

