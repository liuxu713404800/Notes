阻塞：
	因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中锁释放它所占用的资源，这就是阻塞；

死锁：
	两个或者两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象；

死锁解决方式：
	回滚造成死锁的多个事务：
		虽然简单，但是会导致并发性能的下降；
	超时：
		当两个或者多个事务互相等待时，当一个等待时间超过某个阈值时，其中一个事务回滚，另一个等待事务就能继续进行；
		超时机制虽然简单，但是若超时事务所占的权重比较大时，例如更新了大量的行，占用了较多的undo，此时回滚另一个事务更合适；
		当前数据库普遍采用wait-for graph(等待图)的方式进行死锁检测，回滚undo日志较小的事务。

死锁示例：
	————————————————————————————————————————————————————
		时间	|					会话A	 					|				 会话B
	————————————————————————————————————————————————————
	 	T1		|				BEGIN;							|				
	————————————————————————————————————————————————————
				|mysql> select * from user where 				|
		T2		|		uid = 1 for update;						|				
				|1 row in set (0.05 sec)						|			
	————————————————————————————————————————————————————
		T3		|												|				BEGIN;
	————————————————————————————————————————————————————
				|												|mysql> select * from user where 
		T4		|												|		uid = 2 for update;		
				|												|1 row in set (0.05 sec)
	————————————————————————————————————————————————————
				|mysql> select * from user where 				|
		T5		|		uid = 2 for update;						|				
				|#此处没有返回值，处于等待状态					|			
	————————————————————————————————————————————————————
				|												|mysql> select * from user where 
		T6		|1 row in set (10.10 sec)						|		uid = 2 for update;		
				|												|ERROR 1213 (40001): Deadlock found when trying 
				|												| to get lock; try restarting transaction
	————————————————————————————————————————————————————