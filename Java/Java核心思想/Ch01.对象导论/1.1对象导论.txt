1.1 抽象过程
Java语言特性表现出一种纯粹的面向对象测程序设计方式：
1）万物皆对象。对象可视为一种奇特的变量，可以存储数据，也可以对自身进行操作；
2）程序是对象的集合，他们通过发送消息来告诉彼此所要做的；
3）每个对象都有自己的由其他对象所构成的存储。可以通过创建包含现有对象的包的方式来创建新类型的对象；
4）每个对象都有类型；
5）某一特定对象的所有对象都可以接收同样的消息；



1.2 每个对象都有一个接口
1）第一个面向对象的语言为Simula-67；
2）每个对象都只能满足某些请求，这些请求由对象的接口所定义。接口确定了对某一特定对象所能发出的请求。


1.3 每个对象都提供服务
整单视图开发或者理解一个程序设计时，最好的方法就是将对象视为“服务提供者”。程序本身将想用户提供服务，它将调用其他对象提供的服务来实现这一目的。我们的目标就是能够创造能够提供理想的服务来解决问题的一系列对象。
将对象看作服务的提供者还有一个附带的好处：提高对象的内聚性。高内聚是软件设计的基本质量要求之一

1.4 被隐藏的具体实现
将程序开发人员按照角色分为类创建者和客户端程序员（即类定义者和类使用者），将类的具体实现隐藏起来，可以起到保护类的作用。

1.5 复用的具体实现
在创建新类时，应该首先考虑组合，采用这种方式，设计会变得更加清晰；

1.6 继承
基类与导出类（继承类）产生差异的方法有两种：
1）添加新方法；2）覆盖基类方法

继承只覆盖基类中的方法而不添加新的方案，可以被视为纯粹替代，通常称之为替代原则。某种意义上来说，这是处理继承的理想方式，基类与导出类之间的关系称为is-a（是一个）关系。
有时候必须在导出类中添加新的接口元素，这样也就扩展了接口。这种情况我们可以描述为is-like-a(像是一个)关系

1.7 伴随多待的可互换对象
在处理类型的层次结构时，经常想把一个对象不当做他所属的特定类型来对待，而是将其当做其基类的对象来对待。这使得人们可以编写出不依赖于特定类型的代码。
前期绑定:编译器产生一个具体的函数的名字的调用，运行时将这个调用解析到将要被执行的代码的绝对地址；
后期绑定:程序直到运行时才能确定代码的地址；
Boy extends Person; Person person1 = new Boy();
Girl extends Person; Person person2 = new Girl();
Java当中的方法只有final，static，private和构造方法是前期绑定。Java使用一小段特殊的代码来替代绝对地址的调用，这段代码根据对象中存储的信息来计算方法的地址。

1.8 单根继承结构
Java所有的类都继承自Object。单根继承结构保证所有对象都具备某些功能

1.9 容器
通过创建一种新的对象类型，来持有对其他对象的引用，这种数据结构叫做容器（Java中使用“集合”这个术语）。典型的容器如List，Map，Set等等。
从设计的观点来看，真正需要的只是一个可以被操作的，能够解决问题的序列。如果单一容器满足所有需求，就没有理由设计不同类型的序列了。
但是从实际结果来看，设计多种容器有更多的好处，主要原因有两个：
1）不同容器提供了不同的类型接口和外部行为，特定容器的解决方案可能比其他容器灵活的多。例如有的场景使用栈更合适，有的场景使用队列更合适。
2）不同容器的执行效率和消耗代价区别是非常大的。例如ArrayList和LinkedList。
Java1.5之前，容器的存储对象只能是Object。存入时向上泛化，取出时再向下具化，非常不方便。1.5之后容器增加了参数化类型(Java中称为泛型)，支持容器存储类的类型；
Tips：容器不能持有基本类型，但是Java1.5之后的自动包装功能可以说是完全消除了这个影响。

1.10 对象的创建和生命期
C++认为效率控制是最重要的议题，所以对象的存储空间和生命周期在编写程序时控制，但容易造成内存泄漏；
Java提供了垃圾回收器机制，可以自动发现对象不再被使用并销毁；

1.11 异常处理
异常是一种对象，它从错误的低点被“抛出”并且专门设定的异常处理器“捕获”
Java内置异常处理并且必须强制必须使用

1.12 并发编程
Java并发是内置于语言当中的，避免了通过了解机器底层支持编写中断程序的困难。
并发中最大的隐患在于，共享资源