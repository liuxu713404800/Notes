Java对象创建过程：
    虚拟机在遇到new指令时，首先检查这个指令参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，则先执行相应的类加载过程；
    类加载完成后，虚拟机将为类分配内存。对象所需内存大小在类加载完成后便可以完全确定，然后从Java堆中划分出来；
    Java堆又有规整（连续内存）和不规整（多个内存块）的区别，有不同的划分策略；

对象存储：
    在HotSpot虚拟机中，对象在内存中存储包含三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）:
    对象头：
        对象头包含两个部分信息:
        1.存储独享自身运行时数据，如hash码、GC分带年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。因为事实上对象数据所占用的空间较大，超过对象头的存储能力，对象头中存储的数据是关于对象运行时各种状态记载（个人理解）；
        2.指定对象类元数据的指针，表明这个对象是是哪个类的实例；
    实例数据：
        代码中所定义的各种类型的字段内容；
    对齐填充：
        占位符作用，非必然存在。因为HotSpot必须要求对象的起始地址是8字节的证书倍；


对象访问定位：
    Java程序需要通过栈上的reference数据操作堆上的具体对象，目前主流的方位方式有使用句柄和直接指针两种；
    使用句柄：
        1.Java堆中划出一块区域作为句柄池，reference中存储的对象的句柄地址，句柄中包含对象实例数据和数据类型各自的具体地址信息：
        ------------------------------------------------------------------------------------
        |  Java栈 |
        |_________|     -------------------------Java堆-------------------------------------
        |   int   |             句柄池               |                 实例池
        |         |        ------------------        |
        |  short  |          实例数据指针      ——————————————————————————>    对象实例数据
        |         |          类型数据指针   __
        |         |        -----------------|--------------------------------------------
        |reference|     --------------------|------方法区----------------------------------
        |         |                         |
        |         |                         |-------------------------->    对象类型数据
        ------------------------------------------------------------------------------------
        2.直接地址访问，堆中需要存放对象类型的地址：
        ------------------------------------------------------------------------------------
        |  Java栈 |                              Java堆
        |_________|     --------------------------------------------------------------------
        |   int   |
        |         |
        |  short  |          对象实例数据
        |         |          类型数据指针   __
        |         |                         |       方法区
        |reference|     --------------------|---------------------------------------------
        |         |                         |
        |         |                         |-------------------------->    对象类型数据
        ------------------------------------------------------------------------------------

OutOfMemoryError异常:
    除了程序计数器外，虚拟机的其他几个运行时区域都有发生OutOfMemoryError的可能；
    Java堆溢出：
        将堆的最小值-Xms和堆的最大值-Xmx设置为一样可以避免堆的自动扩展，通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前内存堆快照以便时候进行分析；
    虚拟机栈和本地方法栈溢出：
        虚拟机栈由-Xss参数设置，本地方法栈由-Xoss参数设置；
        当方法请求栈的深度大院虚拟机所允许的深度，将抛出StackOverflowError异常；
        如果虚拟机无法扩展申请到足够的内存时，将抛出OutOfMemoryError异常；
        上述描述是Java虚拟机的规范，然而其实两种描述有重叠之处：栈空间无法继续分配是归为内存太小还是已使用栈空间太大？
    方法区和运行时常量池：
        方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。运行产生大量的类去填满方法区，会产生溢出；
    直接内存：
        这个比较好理解，系统内存是有空间大小的
