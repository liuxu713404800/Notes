Java虚拟机所管理的内存将会包括以下几个运行时的数据区域：
	程序计数器（Program Counter Register）：
		程序计数器是线程私有的；
		记录了程序执行的字节码的行号和指令，通过改变计数器的值来选择执行下一个字节码指令；
		如果线程正在这行的是一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是一个native方法，这个计数器的值为空。
	Java虚拟机栈（Java VM Stacks）：
		Java虚拟机栈也是线程私有的；
		每个Java方法执行时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等等，方法执行完成后，意味着栈帧在虚拟机栈中出栈；
		当方法请求栈的深度大院虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机无法扩展申请到足够的内存时，将抛出OutOfMemoryError异常；
	本地方法栈（Native Method Stack）：
		native是一个计算机函数，一个Native Method就是一个Java调用非Java代码的接口，方法的实现由非Java语言实现；
		本地方法栈与虚拟机栈作用相似，只不过使用的是native方法，同样有StackOverflowError和OutOfMemoryError异常；
		有的虚拟机（Sun HotSpot）甚至将本地方法栈和虚拟机栈合二为一；
	Java堆（Java Heap）：
		线程公有；
		Java堆一般是Java虚拟机所管理的内存中最大的一块，用来存放和销毁对象；
	方法区（Method Area）：
		线程公有；
		用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
    运行常量池：
        属于方法区的一部分，用于存储在编译期间生成的各种字面量和符号引用，如类名、访问修饰符、常量池、字段描述、方法描述等；
    直接内存：
        它可以使用native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作；
        直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显；直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显

	个人的理解如下：
		栈的话针对单线程，一些比较轻量级但是较为关键的数据；堆的话更多的是用来给运行时产生的新的数据进行内存的分配；
		方法区的话，更多倾向于预先能够定义好的方法或者数据本身；
