垃圾回收概念：
	在Java程序运行时，程序计数器、虚拟机栈、本地方法栈3个区域随线程生，随线程灭：栈中的栈帧随着方法的进入和退出进栈和出栈，，每一帧栈在内存中分配多少内存基本上是类结构确定就已经知道了。所以可以认为这三个区域运行时基本不需要考虑回收问题；
	Java堆和方法区不一样，一个接口中多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内也可能不一样，只有在运行期间才会知道创建了哪些对象，这部分内存分配和回收都是动态，垃圾收集器所关注的是这部分内存。

判断对象消亡条件：
	1.引用计数算法：
		对一个变量，每当引用引用计数器就+1，引用失效就-1，计数器为0时对方对象消亡。这种实现方式比较简单，效率也高，最著名的应该是Python了。但是这个方案存在的问题是，不能解决循环引用的问题；Java虚拟机也并未采取此方案。
	2.可达性分析算法：
		这个算法的基本思想就是以一系列“GC ROOTS”的对象为起始点，从这些结点向下搜多，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连的时，则说明此对象是不可用的，此时这些对象将被判定为可回收对象。
		Java语言中，可作为GC Roots的对象包含以下几种：
		虚拟机栈（帧栈中的本地变量表）中引用的对象；
		方法区中类静态属性的的引用对象；
		方法区中常量引用的对象；
		本地方法栈中JNI（Java Native Interface，即Native方法）引用对象；

再谈引用：
	JDK1.2以前，Java中的引用地址只有存在或者不存在两种状态，有些狭隘。比如说我们想描述这样一类对象：当内存空间足够时，能保留在内存之中；如果内存空间在垃圾收集后仍是十分紧张，那么就抛弃这些对象，JDK1.2以前的引用是不足以描述的。
	JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Sofe Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）四种，强度依次减弱：
	强引用：
		程序代码中普遍存在，类似“Object obj = new Object()” ,只要存在，垃圾回收起就不会回收掉被引用的对象。
	软引用：
		描述非必需存在的对象，对于这些对象，在系统将要发生存溢异常之前，才会把这些对象回收。
	弱引用：
		也是用来描述非必需对象的，只能存活到下一次垃圾收集之前。
	虚引用：
		对对象生存时间完全没有影响，只作为整个对象被回收时收到一个系统通知。

两次标记与回收：
	对于可达性算法分析不可达的对象，首先会被执行finalize()方法，此方法只能执行一次，被执行的对象会被放置到F-Queue的队列中。稍后GC会对F-Queue中的对象进行第二次小规模标记。在finalize()中，如果对象重新建立引用关系，那么第二次标记中将会移出F-Queue，否则会被GC回收。


回收方法区：
	主要回收两部分内容：废弃常量和无用类；
	废弃常量：
		判定比较简单，引用常量池和其他地方没有引用这个字面量，就发生回收；
	无用类：
		需要满足以下三个条件才是无用的类：
		1.加载该类的所有实例都被回收了。
		2.加载该类的ClassLoader被回收了。
		3.该类对应的java.lang.Class对象没有在任何地方被引用。