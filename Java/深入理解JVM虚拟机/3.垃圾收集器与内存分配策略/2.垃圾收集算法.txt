收集算法：
	标记-清除算法：
		最基础的收集算法，算法分为两个阶段，“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象；
		该算法主要有两个问题：
			1.效率问题，标记和清除的两个过程效率都不高；
			2.空间问题，标记清除之后会产生大量不连续内存碎片，空间碎片太多可能会导致后续运行过程中，遇到分配较大对象时，无法找到足够的连续内存不得不提前触发另一次垃圾收集动作。
	复制算法：
		将内存容量分为大小相等的两块，每次使用一块，这块用完了，就将存活的对象复制到另一块上面，再把已使用的空间清理掉；
		该算法的主要问题：
			将内存缩小到一半，代价有点高。
		现代商业虚拟机都是采用这种算法回收新生代，研究表明，对象的98%都是的存活时间很短，按照1：1的比例划分内存空间并不合适，而是将内存分为一块较大的Eden空间和两块Survivor空间。回收发生时，将Eden和Survivor中还存活的对象一次性地复制到另一块Survivor上，清理掉Eden和用过的Survivor空间。
	标记-整理算法：
		与“标记-清除”算法类似，但后续步骤不是直接都可回收的对象进行清理，而是所有存活的对象都向一端移动，形成连续的内存块。
	分代收集算法：
		根据对象的存活周期将内存分为几块，一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算发。

HotSpot算法实现：
	枚举根节点：
		