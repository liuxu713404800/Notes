1.CPU核心数和线程的关系
核心数：线程数 = 1 ：1；
因特尔提出超线程的概念，1 ：2

2.CPU时间片轮转机制
RR调度（时间片轮转）；
上下文切换（一般会花费5k-2w个时钟周期）；

3.进程和线程的区别
进程：进程是系统分配资源的最小单位，进程内部有多个线程，多个线程会共享进程资源
线程：CPU调度的最小单位，线程本身不拥有资源

4.并行和并发的区别
并行表示同一时刻的处理事情能力
并发表示在单位时间内可以处理事情的能力

5.高并发编程意义和注意事项
充分利用CPU资源；加快用户响应时间；有助保持代码的模块化
共享资源，有可能存在冲突；死锁；太多线程，大部分时间用在切换，实际上降低效率；占用系统资源太多，搞垮机器；


6.java天生就是多线程，有一些几种开启新线程的方式
1）Thread 
2）Runnable 
3）Callable


7.java中，如何线程安全停止工作
java线程是协作式的，不是抢占试的；java这么设计的目的是为了让每个线程有时间处理剩余工作
自然状态：
1）自然执行完；2）抛出异常
手工停止：
不建议方式：
stop()，resume()无法保证线程资源的正常释放
suspend()，挂起，线程不会释放资源，容易造成死锁
建议方式：
interrupt() 中断一个线程，并不是强制关闭这个线程，只是将中断标志位设置为true
isInterrupted() 判定当前线程是否处于中断状态
static方法interrupted() 判断当前线程是否处于中断状态，并将中断标志位改为false
方法抛出InterruptedException时，线程的终端标志位会被复位成false


8.线程优先级
线程优先级的范围为1-10，缺省为5;优先级高的线程分配时间片的数量要高于线程优先级低的数量
使用setPriority；但是不同操作系统对优先级的实现并不相同，甚至有的操作系统都忽略这个配置，所以这是一个不可靠的配置


9.守护线程
在Java中有两类线程：User Thread(用户线程)、Daemon Thread(守护线程) 
用个比较通俗的比如，任何一个守护线程都是整个JVM中所有非守护线程的保姆：
只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。
Daemon的作用是为其他线程的运行提供便利服务，守护线程最典型的应用就是 GC (垃圾回收器)。
User和Daemon两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果 User Thread已经全部退出运行了，只剩下Daemon Thread存在了，虚拟机也就退出了。 因为没有了被守护者，Daemon也就没有工作可做了，也就没有继续运行程序的必要了，所以，守护线程是和主线程一起退出的。
