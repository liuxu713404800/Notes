在swoole中，有一个master进程（父进程）和多个worker进程（子进程），这个和nginx，fpm属于同一中模型


1.进程包含两个最重要的部分，
一个是内存，比如记录各种变量值，堆栈之类的
另一个是上下文环境，操作系统的资源，信号量，自身状态等等

2.子进程拥有独立的内存和上下文环境
在创建出来的时候，子进程回复制子进程的内存空间和上下文环境。注意，这里是复制，并不是共享内存，这和线程是不同的。
例如父进程的内存中有变量a=1，子进程进行复制之后，将变量修改为a=2，那么父进程中间的变量仍然是a=1


3.进程间的通讯方式

共享内存不属于任何一个进程
共享内存中分配的内存可以被任何进程访问，只要有这块共享内存的key值就好
即使进程退出，共享内存仍然可以技术保留


4.swoole结构
1.master用来处理swoole核心的事件驱动
Main Reactor：总线程，负责线程任何调度
Reactor：线程，每一个子线程包含一个epoll实例的实现
2.manager
负责管理，不会运行任何用户层的业务逻辑，只负责进程的管理和分配
3.worker
主逻辑进程，处理来自客户端的请求
4.task
异步工作进程，处理耗时较长的任务

swoole中进程间的通信是通过管道实现的
当woker进程被关闭，manager会重新拉起一个进程，保证woker的总数量

5.task与woker
task与woker之间是通过unix Sock管道进行通讯的，也可以通过消息队列进行实现
常见问题：
1.Task传递数据大小
数据小于8K，直接通过管道传递，数据大于8K，写入临时文件传递
2.Task传递对象
可以通过序列化传递一个对象的拷贝；
Task中对对象的改变不会反映到Worker进程中；
数据库连接，网络连接对象不可以传递。
3.Task的onFinish回调
Task的onFinish回调会发回调用task方法的Worker进程(投递者)


6.timer
timer定时器用来替代crontab，来实现一个精度更高（毫秒级别）的定时器；
在1.7.x之前，timer是一个线程，这个线程会在一定的间隔唤醒，来检查各个定时器是否能够使用
这种方式有以下两个问题：
1）创建的定时器的数量有限，本轮还没循环完，下轮就又开始了；
2）容错性小，线程挂掉，整个定时器任务失效；

新版swoole采用注册一个epoll函数，如果超过timeout，这个函数会返回，去回调指定函数，检查内存中是否有可用的定时器
使用最小堆，存放timer
